"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getExecutable = getExecutable;
exports.getMavenRootDirectory = getMavenRootDirectory;
exports.getPlugin = getPlugin;
exports.getExpressionValue = getExpressionValue;
exports.addProjectToAggregator = addProjectToAggregator;
exports.addLibraryToProjects = addLibraryToProjects;
exports.addMissedProperties = addMissedProperties;
exports.getLocalRepositoryPath = getLocalRepositoryPath;
exports.getArtifactId = getArtifactId;
exports.getGroupId = getGroupId;
exports.getVersion = getVersion;
exports.getParentProjectValues = getParentProjectValues;
exports.extractRootPomValues = extractRootPomValues;
exports.getSkipAggregatorProjectLinkingOption = getSkipAggregatorProjectLinkingOption;
exports.getAggregatorProjectRoot = getAggregatorProjectRoot;
const xml_1 = require("@jnxplus/xml");
const devkit_1 = require("@nx/devkit");
const child_process_1 = require("child_process");
const fs = require("fs");
const path = require("path");
const xmldoc_1 = require("xmldoc");
function getExecutable() {
    let executable = '';
    const mavenRootDirectory = getMavenRootDirectory();
    const mavenCli = process.env['NX_MAVEN_CLI'];
    if (mavenCli) {
        if (mavenCli !== 'mvnw' && mavenCli !== 'mvn' && mavenCli !== 'mvnd') {
            throw new Error(`Wrong value for NX_MAVEN_CLI. Please choose between mvnw, mvn and mvnd.`);
        }
        if (mavenCli === 'mvnw') {
            executable = process.platform.startsWith('win') ? 'mvnw.cmd' : './mvnw';
        }
        else {
            executable = mavenCli;
        }
    }
    else if (process.env['NX_SKIP_MAVEN_WRAPPER'] === 'true') {
        //TODO NX_SKIP_MAVEN_WRAPPER is deprecated, please use NX_MAVEN_CLI instead
        devkit_1.logger.warn('NX_SKIP_MAVEN_WRAPPER is deprecated, please use NX_MAVEN_CLI instead');
        executable = 'mvn';
    }
    else {
        const isWrapperExists = isWrapperExistsFunction(mavenRootDirectory);
        if (isWrapperExists) {
            executable = process.platform.startsWith('win') ? 'mvnw.cmd' : './mvnw';
        }
        else {
            executable = 'mvn';
        }
    }
    if (process.env['NX_MAVEN_CLI_OPTS']) {
        executable += ` ${process.env['NX_MAVEN_CLI_OPTS']}`;
    }
    const localRepoRelativePath = getLocalRepoRelativePath();
    if (localRepoRelativePath) {
        const mavenRepoLocal = path.join(devkit_1.workspaceRoot, mavenRootDirectory, localRepoRelativePath);
        executable += ` -Dmaven.repo.local=${mavenRepoLocal}`;
    }
    return executable;
}
function isWrapperExistsFunction(mavenRootDirectory) {
    const mvnwPath = path.join(devkit_1.workspaceRoot, mavenRootDirectory, 'mvnw');
    return fs.existsSync(mvnwPath);
}
function getMavenRootDirectory() {
    const plugin = getPlugin();
    if (typeof plugin === 'string') {
        return '';
    }
    const options = plugin === null || plugin === void 0 ? void 0 : plugin.options;
    if (typeof options === 'object' &&
        options &&
        'mavenRootDirectory' in options &&
        typeof options.mavenRootDirectory === 'string') {
        return options.mavenRootDirectory;
    }
    return '';
}
function getPlugin() {
    var _a;
    const nxJsonPath = path.join(devkit_1.workspaceRoot, 'nx.json');
    const nxJson = (0, devkit_1.readJsonFile)(nxJsonPath);
    const plugin = ((_a = nxJson === null || nxJson === void 0 ? void 0 : nxJson.plugins) !== null && _a !== void 0 ? _a : []).find((p) => typeof p === 'string'
        ? p === '@jnxplus/nx-maven'
        : p.plugin === '@jnxplus/nx-maven');
    return plugin;
}
function getProjectRootFromTree(tree, mavenRootDirectory, projectName) {
    let projectRoot = '';
    try {
        projectRoot = (0, devkit_1.readProjectConfiguration)(tree, projectName).root;
        return projectRoot;
    }
    catch (err) {
        devkit_1.logger.warn(err);
        const mavenRootDirAbsolutePath = path.join(devkit_1.workspaceRoot, mavenRootDirectory);
        const projectBasedir = getExpressionValue('project.basedir', mavenRootDirAbsolutePath, projectName);
        projectRoot = path.relative(devkit_1.workspaceRoot, projectBasedir);
        return projectRoot;
    }
}
function getExpressionValue(expression, mavenRootDirAbsolutePath, projectName) {
    let command = `${getExecutable()} help:evaluate -Dexpression=${expression} -q -DforceStdout`;
    if (projectName) {
        command += ` -pl :${projectName}`;
    }
    return (0, child_process_1.execSync)(command, {
        cwd: mavenRootDirAbsolutePath,
        env: process.env,
        encoding: 'utf8',
        stdio: 'pipe',
        windowsHide: true,
    })
        .toString()
        .trim();
}
function addProjectToAggregator(tree, options) {
    const parentProjectPomPath = path.join(options.aggregatorProjectRoot, 'pom.xml');
    const xmlDoc = (0, xml_1.readXmlTree)(tree, parentProjectPomPath);
    const aggregatorProjectAbsolutPath = path.join(devkit_1.workspaceRoot, options.aggregatorProjectRoot);
    const projectAbsolutePath = path.join(devkit_1.workspaceRoot, options.projectRoot);
    const moduleRelativePath = path
        .relative(aggregatorProjectAbsolutPath, projectAbsolutePath)
        .replace(new RegExp(/\\/, 'g'), '/');
    const fragment = new xmldoc_1.XmlDocument(`<module>${moduleRelativePath}</module>`);
    let modules = xmlDoc.childNamed('modules');
    if (modules === undefined) {
        xmlDoc.children.push(new xmldoc_1.XmlDocument(`
    <modules>
    </modules>
  `));
        modules = xmlDoc.childNamed('modules');
    }
    if (modules === undefined) {
        throw new Error('Modules tag undefined');
    }
    modules.children.push(fragment);
    tree.write(parentProjectPomPath, (0, xml_1.xmlToString)(xmlDoc));
}
function addLibraryToProjects(tree, options) {
    devkit_1.logger.info(`Adding lib ${options.projectName} to projects: ${JSON.stringify(options.parsedProjects)}`);
    for (const projectName of options.parsedProjects) {
        const projectRoot = getProjectRootFromTree(tree, options.mavenRootDirectory, projectName);
        const filePath = path.join(projectRoot, 'pom.xml');
        const xmlDoc = (0, xml_1.readXmlTree)(tree, filePath);
        const dependency = new xmldoc_1.XmlDocument(`
		<dependency>
			<groupId>${options.groupId}</groupId>
			<artifactId>${options.projectName}</artifactId>
			<version>${options.projectVersion}</version>
		</dependency>
  `);
        let dependencies = xmlDoc.childNamed('dependencies');
        if (dependencies === undefined) {
            xmlDoc.children.push(new xmldoc_1.XmlDocument(`
      <dependencies>
      </dependencies>
    `));
            dependencies = xmlDoc.childNamed('dependencies');
        }
        if (dependencies === undefined) {
            throw new Error('Dependencies tag undefined');
        }
        dependencies.children.push(dependency);
        tree.write(filePath, (0, xml_1.xmlToString)(xmlDoc));
    }
}
function addMissedProperties(tree, options) {
    let fileChanged = false;
    const pomPath = path.join(options.mavenRootDirectory, 'pom.xml');
    const xmlDoc = (0, xml_1.readXmlTree)(tree, pomPath);
    //properties
    let properties = xmlDoc.childNamed('properties');
    if (properties === undefined) {
        xmlDoc.children.push(new xmldoc_1.XmlDocument(`
    <properties>
    </properties>
  `));
        properties = xmlDoc.childNamed('properties');
    }
    if (properties === undefined) {
        throw new Error('Properties tag undefined');
    }
    if (options.language === 'kotlin') {
        const kotlinVersionXml = properties.childNamed('kotlin.version');
        if (kotlinVersionXml === undefined) {
            properties.children.push(new xmldoc_1.XmlDocument(`
        <kotlin.version>${options.kotlinVersion}</kotlin.version>
`));
            fileChanged = true;
        }
    }
    if (options.framework === 'spring-boot') {
        const b = isParentPomExits(xmlDoc, 'spring-boot-starter-parent');
        if (!b) {
            const springBootVersion = properties.childNamed('spring.boot.version');
            if (springBootVersion === undefined) {
                properties.children.push(new xmldoc_1.XmlDocument(`
    <spring.boot.version>${options.springBootVersion}</spring.boot.version>
  `));
                fileChanged = true;
            }
        }
    }
    if (options.framework === 'quarkus') {
        const quarkusVersion = properties.childNamed('quarkus.version');
        if (quarkusVersion === undefined) {
            properties.children.push(new xmldoc_1.XmlDocument(`
      <quarkus.version>${options.quarkusVersion}</quarkus.version>
    `));
            fileChanged = true;
        }
    }
    if (options.framework === 'micronaut') {
        const b = isParentPomExits(xmlDoc, 'micronaut-parent');
        if (!b) {
            const micronautVersion = properties.childNamed('micronaut.version');
            if (micronautVersion === undefined) {
                properties.children.push(new xmldoc_1.XmlDocument(`
    <micronaut.version>${options.micronautVersion}</micronaut.version>
  `));
                fileChanged = true;
            }
        }
    }
    if (fileChanged) {
        tree.write(pomPath, (0, xml_1.xmlToString)(xmlDoc));
    }
}
function isParentPomExits(xmlDoc, parentPom) {
    const parentXml = xmlDoc.childNamed('parent');
    if (parentXml === undefined) {
        return false;
    }
    const artifactIdXml = parentXml.childNamed('artifactId');
    return parentPom === (artifactIdXml === null || artifactIdXml === void 0 ? void 0 : artifactIdXml.val);
}
function getDependencyManagement(xmlDoc) {
    if (isParentPomExits(xmlDoc, 'spring-boot-starter-parent')) {
        return 'spring-boot-parent-pom';
    }
    if (isParentPomExits(xmlDoc, 'micronaut-parent')) {
        return 'micronaut-parent-pom';
    }
    return 'bom';
}
function getLocalRepoRelativePath() {
    const plugin = getPlugin();
    if (typeof plugin === 'string') {
        return '';
    }
    const options = plugin === null || plugin === void 0 ? void 0 : plugin.options;
    if (typeof options === 'object' &&
        options &&
        'localRepoRelativePath' in options &&
        typeof options.localRepoRelativePath === 'string') {
        return options.localRepoRelativePath;
    }
    return '';
}
function getLocalRepositoryPath(opts, mavenRootDirAbsolutePath) {
    let localRepositoryPath;
    const localRepoRelativePath = (opts === null || opts === void 0 ? void 0 : opts.localRepoRelativePath)
        ? opts.localRepoRelativePath
        : '';
    if (localRepoRelativePath) {
        const mavenRootDirectory = (opts === null || opts === void 0 ? void 0 : opts.mavenRootDirectory)
            ? opts.mavenRootDirectory
            : '';
        localRepositoryPath = (0, devkit_1.joinPathFragments)(mavenRootDirectory, localRepoRelativePath);
    }
    else {
        localRepositoryPath = getExpressionValue('settings.localRepository', mavenRootDirAbsolutePath);
    }
    return localRepositoryPath;
}
function getArtifactId(pomXmlContent) {
    const artifactIdXml = pomXmlContent.childNamed('artifactId');
    if (artifactIdXml === undefined) {
        throw new Error(`ArtifactId not found in pom.xml`);
    }
    return artifactIdXml.val;
}
function getGroupId(artifactId, pomXmlContent) {
    let groupId;
    const groupIdXml = pomXmlContent.childNamed('groupId');
    if (groupIdXml === undefined) {
        groupId = getParentGroupId(pomXmlContent);
    }
    else {
        groupId = groupIdXml.val;
    }
    if (!groupId) {
        throw new Error(`GroupId is not set for project ${artifactId}`);
    }
    return groupId;
}
function getParentGroupId(pomXmlContent) {
    const parentXml = pomXmlContent.childNamed('parent');
    if (parentXml === undefined) {
        return undefined;
    }
    const groupIdXml = parentXml.childNamed('groupId');
    if (groupIdXml === undefined) {
        return undefined;
    }
    return groupIdXml === null || groupIdXml === void 0 ? void 0 : groupIdXml.val;
}
function getVersion(artifactId, pomXmlContent) {
    let version;
    const versionXml = pomXmlContent.childNamed('version');
    if (versionXml === undefined) {
        version = getParentVersion(pomXmlContent);
    }
    else {
        version = versionXml.val;
    }
    if (!version) {
        throw new Error(`Version is not set for project ${artifactId}`);
    }
    return version;
}
function getParentVersion(pomXmlContent) {
    const parentXml = pomXmlContent.childNamed('parent');
    if (parentXml === undefined) {
        return undefined;
    }
    const versionXml = parentXml.childNamed('version');
    if (versionXml === undefined) {
        return undefined;
    }
    return versionXml === null || versionXml === void 0 ? void 0 : versionXml.val;
}
function getParentProjectValues(tree, mavenRootDirectory, projectRoot, parentProject) {
    let pomXmlContent;
    let parentProjectRoot;
    if (!parentProject) {
        parentProjectRoot = mavenRootDirectory;
        pomXmlContent = (0, xml_1.readXmlTree)(tree, (0, devkit_1.joinPathFragments)(parentProjectRoot, 'pom.xml'));
    }
    else {
        parentProjectRoot = getProjectRootFromTree(tree, mavenRootDirectory, parentProject);
        const parentProjectPomPath = path.join(parentProjectRoot, 'pom.xml');
        pomXmlContent = (0, xml_1.readXmlTree)(tree, parentProjectPomPath);
    }
    const relativePath = (0, devkit_1.joinPathFragments)(path.relative(projectRoot, parentProjectRoot), 'pom.xml');
    const parentProjectName = getArtifactId(pomXmlContent);
    const parentGroupId = getGroupId(parentProjectName, pomXmlContent);
    const parentProjectVersion = getVersion(parentProjectName, pomXmlContent);
    return [relativePath, parentProjectName, parentGroupId, parentProjectVersion];
}
function extractRootPomValues(tree, mavenRootDirectory, framework) {
    var _a, _b, _c;
    const rootPomXmlContent = (0, xml_1.readXmlTree)(tree, path.join(mavenRootDirectory, 'pom.xml'));
    let quarkusVersion = '';
    if (framework === 'quarkus') {
        quarkusVersion =
            (_c = (_b = (_a = rootPomXmlContent === null || rootPomXmlContent === void 0 ? void 0 : rootPomXmlContent.childNamed('properties')) === null || _a === void 0 ? void 0 : _a.childNamed('quarkus.version')) === null || _b === void 0 ? void 0 : _b.val) !== null && _c !== void 0 ? _c : 'quarkusVersion';
    }
    return [quarkusVersion, getDependencyManagement(rootPomXmlContent)];
}
function getSkipAggregatorProjectLinkingOption(plugin) {
    if (typeof plugin === 'string') {
        return false;
    }
    const options = plugin === null || plugin === void 0 ? void 0 : plugin.options;
    if (typeof options === 'object' && options && 'graphOptions' in options) {
        const graphOptions = options === null || options === void 0 ? void 0 : options.graphOptions;
        if (typeof graphOptions === 'object' &&
            graphOptions &&
            'skipAggregatorProjectLinking' in graphOptions &&
            typeof graphOptions.skipAggregatorProjectLinking === 'boolean') {
            return graphOptions.skipAggregatorProjectLinking;
        }
    }
    return false;
}
function getAggregatorProjectRoot(tree, aggregatorProject, mavenRootDirectory) {
    if (!aggregatorProject) {
        return mavenRootDirectory;
    }
    return getProjectRootFromTree(tree, mavenRootDirectory, aggregatorProject);
}
//# sourceMappingURL=index.js.map