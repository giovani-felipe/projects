"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDependencies = void 0;
const devkit_1 = require("@nx/devkit");
const path = require("path");
const utils_1 = require("../utils");
const graph_utils_1 = require("./graph-utils");
const createDependencies = (_, context) => {
    const results = [];
    const cachedWorkspaceData = (0, graph_utils_1.getCachedWorkspaceData)();
    const projects = cachedWorkspaceData.projects;
    const plugin = (0, utils_1.getPlugin)();
    const skipAggregatorProjectLinkingOption = (0, utils_1.getSkipAggregatorProjectLinkingOption)(plugin);
    Object.keys(context.filesToProcess.projectFileMap).forEach((source) => {
        Object.values(context.filesToProcess.projectFileMap[source]).forEach((fileData) => {
            const filePath = fileData.file;
            if (path.basename(filePath) === 'pom.xml') {
                const project = projects.find((element) => (0, devkit_1.joinPathFragments)(element.projectRoot, 'pom.xml') === filePath);
                if (!project) {
                    throw new Error(`Can't find project for file: ${filePath}`);
                }
                if (!project.skipProject) {
                    const projectSourceFile = (0, devkit_1.joinPathFragments)(project.projectRoot, 'pom.xml');
                    if (project.parentProjectArtifactId) {
                        const parentProject = (0, graph_utils_1.getProject)(projects, project.parentProjectArtifactId);
                        if (!parentProject.skipProject) {
                            const newDependency = {
                                source: project.artifactId,
                                target: parentProject.artifactId,
                                sourceFile: projectSourceFile,
                                type: devkit_1.DependencyType.static,
                            };
                            (0, devkit_1.validateDependency)(newDependency, context);
                            results.push(newDependency);
                        }
                    }
                    if (skipAggregatorProjectLinkingOption === false) {
                        if (project.aggregatorProjectArtifactId &&
                            project.aggregatorProjectArtifactId !==
                                project.parentProjectArtifactId) {
                            const aggregatorProject = (0, graph_utils_1.getProject)(projects, project.aggregatorProjectArtifactId);
                            if (!aggregatorProject.skipProject) {
                                const newDependency = {
                                    source: project.artifactId,
                                    target: aggregatorProject.artifactId,
                                    sourceFile: projectSourceFile,
                                    type: devkit_1.DependencyType.static,
                                };
                                (0, devkit_1.validateDependency)(newDependency, context);
                                results.push(newDependency);
                            }
                        }
                    }
                    const dependencies = getDependencyProjects(project, projects);
                    for (const dependency of dependencies) {
                        if (!dependency.skipProject) {
                            const newDependency = {
                                source: project.artifactId,
                                target: dependency.artifactId,
                                sourceFile: projectSourceFile,
                                type: devkit_1.DependencyType.static,
                            };
                            (0, devkit_1.validateDependency)(newDependency, context);
                            results.push(newDependency);
                        }
                    }
                    const profileDependencies = getProfileDependencyProjects(project, projects);
                    for (const profileDependency of profileDependencies) {
                        if (!profileDependency.skipProject) {
                            const newDependency = {
                                source: project.artifactId,
                                target: profileDependency.artifactId,
                                sourceFile: projectSourceFile,
                                type: devkit_1.DependencyType.static,
                            };
                            (0, devkit_1.validateDependency)(newDependency, context);
                            results.push(newDependency);
                        }
                    }
                }
            }
        });
    });
    // Remove cached data
    (0, graph_utils_1.removeWorkspaceDataCache)();
    return results;
};
exports.createDependencies = createDependencies;
function getDependencyProjects(project, projects) {
    return projects.filter((p) => project.dependencies.includes(p.artifactId));
}
function getProfileDependencyProjects(project, projects) {
    return projects.filter((p) => project.profileDependencies.includes(p.artifactId));
}
//# sourceMappingURL=create-dependencies.js.map